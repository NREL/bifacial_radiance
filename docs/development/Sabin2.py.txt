#!/usr/bin/env python
# coding: utf-8

# # Example of adding multiple scene objects of different number of modules per row
# 
# 
# ![image-2.png](attachment:image-2.png)

# In[1]:


import os
import numpy as np
import pandas as pd
from pathlib import Path

testfolder = str(Path().resolve().parent.parent / 'bifacial_radiance' / 'TEMP' / 'Sabin')
if not os.path.exists(testfolder):
    os.makedirs(testfolder)
    
print ("Your simulation will be stored in %s" % testfolder)
    
from bifacial_radiance import RadianceObj, AnalysisObj    


# In[2]:


# Import the lib

import bifacial_radiance
import os
from pathlib import Path
import numpy as np
import pandas as pd

# inputs
name='Testrun_UD_2'

# Location 

la = 40.0583  # NJ
lo = -74.4057  # NJ

# MakeModule Parameters

moduletype='test-module'
numpanels = 1 # [ numbers of panels per unit ]
x = 2 # lenght of one panel 
y = 1 # width of one panel

# SceneDict Parameters
pitch = 0.0000001 # m
albedo = 0.2

yrs = 2021 # The year needed
hrs = 2990 # particular hours of the year

hub_height = 4.3 # m
#nMods = 6 # six modules per row.  # This Changes based on optimization
nRows = 1  # 3 row lenght of the list     # This Changes based on optimization

azimuth_ang=30 # Facing south
tilt =35 # tilt.


# Project Intro
# demo = Project


Project = RadianceObj(name, testfolder)
Project.setGround(albedo)
epwfile = Project.getEPW(la,lo) # NJ lat/lon 40.0583Â° N, 74.4057
metdata = Project.readWeatherFile(epwfile,coerce_year=yrs )
Project.gendaylit(hrs)

# Making module with all the variables

module=Project.makeModule(name=moduletype,x=x,y=y,numpanels=numpanels)


# In[17]:


#First row: Azimuth 180 facing south
# This is coming from your code somehow

originsx = [2.5, 4, 8]  # increase with number of rows
originsy = [4, 8, 10]
numModules = [2, 5, 10]


# In[21]:


# Add scene objects in a loop example
# To do analysis on each object you add htis way, call it like sceneDictLast[0] in the analysis.moduleAnalysis function
# i.e. frontscan, backscan = analysis.moduleAnalysis(sceneDictLast[0], sensorsy=3, sensorsx=3, modWanted=1, rowWanted=1)

# FIRST Scene OBJECT

# ALL other Scene Objects LOOP:
sceneArray = []
for ii in range(0, len(numModules)): 
    # Right now I am not changing any parameters so it is just re-appending the same object multiple times.
    sceneDictRow = {'tilt':tilt,'pitch':pitch,'hub_height':hub_height,'azimuth':azimuth_ang, 'nMods': numModules[ii], 
                      'nRows': 1, 'originx': originsx[ii], 'originy': originsy[ii], 'appendRadfile':True }
    sceneArray.append(Project.makeScene(module=moduletype, sceneDict=sceneDictRow))


# In[6]:


octfile = Project.makeOct(Project.getfilelist())


# In[7]:


get_ipython().system('rvu -vf views\\front.vp -e .01 -pe 0.3 -vp 1 -7.5 12 Testrun_UD_2.oct')


# In[12]:


analysis = AnalysisObj(octfile)


# In[14]:


for ii in range(0, len(sceneArray)):
    sceneobject = sceneArray[ii]
    for modWanted in range(0, numModules[ii]):
        frontscan, backscan = analysis.moduleAnalysis(sceneobject, sensorsy=9, sensorsx=1, modWanted=modWanted)
        analysis.analysis(octfile, '_row_'+str(ii)+'_mod'+str(modWanted), frontscan, backscan) 


# In[30]:


# Reduce time by not sampling all modules
for ii in range(0, len(sceneArray)):
    sceneobject = sceneArray[ii]
    for modWanted in range(0, numModules[ii]):
        if (modWanted <= 3) or (modWanted >= numModules[ii]-3):            
            frontscan, backscan = analysis.moduleAnalysis(sceneobject, sensorsy=9, sensorsx=1, modWanted=modWanted)
            analysis.analysis(octfile, '_row_'+str(ii)+'_mod'+str(modWanted), frontscan, backscan) 

# Model a steady state, selecting the 'center row', and the center module in that center row
sceneobject = sceneArray[int(len(sceneArray)/2)]
modWanted = int(numModules[int(len(sceneArray)/2)]/2)

frontscan, backscan = analysis.moduleAnalysis(sceneobject, sensorsy=9, sensorsx=1, modWanted=modWanted)
analysis.analysis(octfile, '_SteadyState_row_'+str(ii)+'_mod'+str(modWanted), frontscan, backscan) 


# In[27]:


for ii in range(0, len(numModules)):
    for modWanted in range(0, numModules[ii]):
        if (modWanted > 3) or (modWanted < numModules[ii]-3):            
            # Copy steady state value
        


# In[ ]:


calculatePerformance()

